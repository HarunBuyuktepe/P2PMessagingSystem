Selamun aleyküm mübarek buraya bilgilendirmeleri yazıcam inş.

How To Run
1.Run NewServer
2.Run NewClient2, bir isim ver bağlantı kurulduktan sonra terminaye server connection yaz konsola wait connection dicek
3.Run NewClient1, yine bir isim ver, sonra send all peers yaz konsola enterla, NewClient2'ye verdiğin ismi ve port numarasını
göreceksin, connect NewClient2'nin adını yaz
4.Client - Client bağlantı kurulduysa 2 pencere açılacak send'e basınca mesajlar terminale düşecektir



15.05.2020 akşam
    harun:
        - Selamun aleyküm, Yasin'den aldığım kısımla geri kalan kısmı bitirdim,
        - 3.kısım sadece key üretmeydi onu NewClient clasında constructer içinde yaptım
        - Yasin'den Message Encryption kısmını aldım direkt AES ile IV ile şifreleme( Crypt . CbcBlockCipherEncrypt metodu)
        - Integrity Check  olayını direkt olarak MAC objesinin length ile kontrol ediliyor, (array concatenate)
         Resistance to Replay Attacks kısmı ise yine array concatenate metoduyla yapıyor
                String count = (macmessage.length+1000000+nonce)+"";
                byte[] lengtMessage = count.getBytes("UTF-8");
                byte[] sendmessage = new byte[message.length + macmessage.length+lengtMessage.length];
                System.arraycopy(lengtMessage, 0, sendmessage, 0, lengtMessage.length);
                System.arraycopy(message, 0, sendmessage, lengtMessage.length, message.length);
                System.arraycopy(macmessage, 0, sendmessage, message.length+lengtMessage.length, macmessage.length);

         bu şekilde birbirine ekleyip gönderiyor, karşı tarafta bu formata uygun açıyor.( Crypt . splityTheArray metodu)

        - File göndermeye bakabilirim, bakamayadabilirim de
        - Şu haliyle bitti...

14.05.2020 gündüz
    harun:
        - Client - Client problemi hile ile çözdüm çaktırmadan public key gönderiyorum, sonra sertifikadan çıkarttığım
        public key ile karşılaştırıyorum, eğer aynısıysa çalışmaya devam ediyor, olması gerektiği gibi şifreli mesajı
        çözüyor.(Adamın sertifikasından public keyini alıyoruz, ve peerdan gelen key ile karşılaştırıyoruz, ve peerdan
        gelen ile çözüyoruz)

13.05.2020 gecesi
    harun:
        - Client - Client handshake zoraki yapıldı
        - elle yaptım anlayacağın, görürsün client2' de , eğer null gelirse 9 yazıyor ona zamanız kalırsa bakıcam
        - Client 1 'de  deneyince istediğimi gönderiyor, client 2'de yemiyor,
        bu hatayı dönüyor :No installed provider supports this key: javax.crypto.spec.SecretKeySpec
        - Şuan handshake olmuş gibi 3'e geçiyorum zaman kalırsa bakarız inşallah

12.05.2020 gündüz
    harun:
        - Client - Client socket bağlantısı açıldı
        - Açılan bağlantılar threadler ile devam ediyor
        - Şu hali ile sadece 1 e 1 görüşme yapılabilir
        - sonraki aşamamız artık bunlar handshake yapıcak, birinci hello göndericek, öteki nonce göndericek vs.

11.05.2020 gündüz
    harun:
        - shared data optimization yapıldı (her iki client'ın paylaştığı, ikiside anlık veriye erişebilir hale geldi)
        - Sertifika kayıt etme yerine server private key'i ile bağlanan client'ın public key'ini şifreliyor ve kayıt ediyor
        - Şifrelenen public keyi elde etmek isteyen peer şifrelenen veriyi server'ın public key'i ile çözünce istediği peer'ın
        public key'ini elde ediyor hale geldi

10.05.2020 gündüz
    harun:
        - serverda public/private keyler oluşturuldu
        - clientların public keyleri server ın private key i ile imzalandı
        - oluşturulan imza user name - dijital imza olarak kayıt edildi
        - oluşturulan imza client tarafından verify edildi
        - client' a tüm imzaların gönderilmesi sağlandı


08.05.2020 gecesi
    harun:
        - Kral yeniden S.a, client server'a gönderdiği bilgilerin ardından bir menü ile karşılaşacak daha kolaylaştırır işi
        - olayı hafiften kavradım,
        - Sen sertifika olayı ekleyince handshaking olayı kalıyor, handshake olayını da kafamda kurdum.
        handshakete karşı tarafa kendi sertifikasını gönderecek gerisi karşılıklı paslaşma.
        - bu arada servera bağlanan peerların bilgilerini bir yer de tutup isteyene gönderme işi de tamam

        şuan top sende, bir konuda daralırsan yazarsın whatsapp'tan

07.05.2020 gündüzü

    harun:
        kral S.a, şuan threadli çalıştı senin kısımları boş bıraktım, görürsün.
        ben şimdi handshaking olayına geçiyorum.
        Bizim bilgisayarcılar whatsapp grubunda sertifika ile ilgili yazmışlar
        bakarsın yüksek ihtimal dedikleri kütüphaneyle çalışmak yorucu olacak sana kolay gelsin


07.05.2020 gecesi
    harun:
        com.CSE4057'ye ödevin dosyaları olacak

        BackupDosyaları yazan yerde thread'li çalışan socket var

        ObjectInputOutput yazan yerde socket içinde obje gönderme örneği var onu threadli yapmaya çalışıyorum

        threadli çalşınca sana bilgi veririm sen orada sertifika oluşturur tekrar clint'a gönderirsin

        Ama henüz thread'le obje gönderemedim,
        bu thread bitince ben servera public key göndericem sonra sen ,
        - sertifika oluşturma,(Server tarafından imzalanması sanırım ödev dosyasına bakarsın) (serverda)
        - arkasından sertifikayı clienta gönderme, (from server to client) //bu kısımda sockette object transferi örneğini ben yapıcam oradan bakarsın
        - Client ta sertifikayı onaylatma ve (at client)
        - server'a onay mesajı gönderme (at client)
        - ardından bir yere kayıt etme (txt falan) (at server)
        işlerini yaparsın,

        oluşturulan sertifikaların nerede kayıt edicez bunuda düşünürüz

        sen yukarıdaki işlere bakarken bende handshaking olayına bakarım inşallah


        tabi önce benim threadli obje göndermeyi halletmem gerekiyor

        tarihli şekilde yazarız iyi olur takibi :)

